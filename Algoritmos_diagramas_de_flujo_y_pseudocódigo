Algoritmos, diagramas de flujo y pseudocódigo
En este notebook, aprenderemos qué es un algoritmo y veremos dos formas distintas pero complementarias de representarlos: a través de diagramas de flujo y de pseudocódigo.

¿Qué es un algoritmo?
En este curso, emplearemos la palabra algoritmo para referirnos a un algoritmo computacional, el cual podemos definir de forma general como una serie de pasos computacionales que transforman datos de entrada en datos de salida.

Nota Esta definición es similar a una vista anteriormente en el notebook 0.1-Qué_es_un_programa.ipynb:

Dentro del paradigma imperativo de la programación, definiremos a un programa como una serie de instrucciones que una computadora puede ejecutar o, en su defecto, interpretar.

Sin embargo, vale la pena reparar en las diferencias:

mientras que un algoritmo siempre inicia tomando datos de entrada y termina devolviendo datos de salida, la definición de programa no hace referencia explícita a un punto de partida en específico, ni a uno de llegada;
mientras que la definición de algoritmo como una serie de pasos computacionales que transforman datos... implica cierta continuidad en la forma en que los datos de entrada se transforman en los de salida, en la definición de programa no encontramos nada similar: basta con tener una serie de instrucciones que sean apenas ejecutables o interpretables, sin mayores exigencias ni restricciones.
Una gran variedad de funcionalidades están implementadas mediante algoritmos, incluyendo:

análisis de datos,
métodos numéricos,
procesamiento de imágenes digitales,
servicios de internet,
sistemas de comercio,
herramientas de encriptación,
motores de búsqueda,
motores de recomendación,
conducción autónoma
y muchas, pero MUCHAS más.

El problema de sorteo
Para ver un ejemplo prototípico, consideremos el siguiente problema, conocido como el problema de sorteo:

Dada una secuencia finita de 
 números 
, obten mediante permutaciones una secuencia 
 tal que 
.

Claramente, este problema se puede solucionar mediante un algoritmo con

entrada 
,
salida 
, donde 
, y cuyos
pasos estén dados por permutaciones en secuencias de números.
Resulta que el sorteo es una operación fundamental en el área de computación, pues muchos programas lo llevan a cabo como un paso intermedio, por lo que existe una gran variedad de algoritmos de sorteo que resuelven el problema anterior; varios de ellos se pueden visualizar en este video (nótese que no parten todos de una misma entrada). Para leer un poco más sobre 16 algoritmos de sorteo específicos, te recomiendo esta página web y, si quieres observar con más calma cómo actúan 6 algoritmos de sorteo diferentes, te recomiendo este sitio interactivo. En cuanto a cuál algoritmo de sorteo es mejor, la respuesta dependerá de muchos factores: desde los más básicos, como la aplicación que se le quiera dar o la cantidad de números a ser sorteados, hasta los más técnicos, como el tipo de procesador o de dispositivo de memoria que se piense usar.

¿Por qué estudiar algoritmos?
La mayoría de los problemas algorítmicos -esto es, problemas que por lo menos sospechamos que se pueden resolver mediante algoritmos- son motivados por aplicaciones prácticas, como algunas de las que enlistamos anteriormente, y tienen varios algoritmos candidatos a ser una solución -muchos de los cuales terminan no siéndolo. Encontrar uno que lo sea, o la "mejor" entre varias soluciones, puede ser una tarea bastante compleja.

Aún así, la principal motivación para estudiar algoritmos es poder demostrar para un problema algorítmico dado que exista una solución correcta y -quizás igual de importante- práctica (es decir, que termine de ejecutarse en una cantidad aceptable de tiempo). Además, dadas las limitaciones físicas de las computadoras, que no pueden tener rapidez ni memoria infinita, al solucionar problemas de manera computacional el tiempo y el espacio (en memoria) se vuelven recursos escasos, por lo que es de suma importancia poder comparar algoritmos en cuanto a la eficiencia que presenten en el uso de estos dos recursos.

¿Cómo podemos representar algoritmos?
Volvamos al problema de sorteo y pensemos en una solución sencilla, dada por los siguientes pasos:

Comparamos los primeros dos números de la secuencia.
Si el número de la izquierda es mayor al de la derecha, los cambiamos de lugar; si no, no les hacemos nada.
Comparamos los siguientes dos números de la secuencia y repetimos el paso 2.
Repetimos el paso 3 hasta haber comparado los últimos dos elementos de la secuencia.
Repetimos los pasos 1 a 4 hasta que la secuencia quede sorteada.
El algoritmo que acabamos de describir es conocido como bubble sort pues, al observar este algoritmo "en acción" en una gráfica de barras, las barras mayores se estabilizan más rápido que las menores, similar a cómo las burbujas más grandes llegan a la superficie más rápido que las chicas.

Aunque no lo demostraremos aquí, intuitivamente podemos ver que este algoritmo constituye una solución correcta al problema de sorteo, por lo que lo usaremos como ejemplo en lo que resta del notebook.

Diagramas de flujo
Recordemos que hemos definido a un algoritmo como una

serie de pasos computacionales que transforman datos de entrada en datos de salida

y que esta definición implica cierta continuidad en las transformaciones de los datos. Por ende, podemos pensar en la manera en que un algoritmo procesa datos de entrada hasta convertirlos en datos de salida como una cadena de procesos o un flujo.

Los diagramas de flujo son una forma de representar algoritmos diagramáticamente y sirven para dilucidar cómo un algoritmo transforma los datos de entrada en los de salida paso a paso. Más aún, los diagramas de flujo también pueden ser de gran utilidad al diseñar algoritmos, en particular, sirviendo como un buen punto de partida.

Por lo general, un diagrama de flujo se representa como una serie de nodos, que indican acciones, conectados por flechas, que indican el flujo; por ello, también son conocidos como gráficas de control de flujo.



Figura 1 Diagrama de flujo que representa un proceso para usar un dispositivo electrónico.

Puedes encontrar una convención sobre símbolos usados comunmente para crear diagramas de flujo aquí.

Ejercicio Crea un diagrama de flujo para el algoritmo de sorteo de burbuja.

Pseudocódigo (revisitado)
Recordemos que en el notebook 0.1-Qué_es_un_programa.ipynb hicimos una distinción entre código y pseudocódigo. La diferencia crucial es que, a pesar de que ambos describen programas (computacionales, en el sentido imperativo), el pseudocódigo no está escrito en ningún lenguaje de programación particular sino que, básicamente, es un código en potencia.

Sorteo de burbuja (Bubble sort)
A continuación, representaremos el algoritmo de sorteo de burbuja mediante pseudocódigo. Para poder hacerlo de una forma sumamente sencilla, debemos primero hacer un poco de combinatoria.

Supongamos que tenemos una secuencia finita de 
 números. Ahora, intuitivamente, el peor caso posible -es decir, aquel que requeriría el máximo número de intercambios entre los números de la secuencia- se da cuando la secuencia de entrada está ordenada de forma totalmente opuesta a la salida que buscamos; esto es, cuando está ordenada de mayor a menor. Supongamos que nos encontramos en el peor caso. Para cambiar al mayor número de la secuencia desde el extremo izquierdo hasta el derecho requerimos 
 traslaciones (permutaciones de elementos adyacentes). Luego, será el segundo mayor número el que se encontrará en el extremo izquierdo, y nos tomará 
 traslaciones llevarlo a su lugar final (el penúltimo). Así seguiremos sucesivamente hasta que el "penúltimo mayor número" (o, equivalentemente, el segundo menor) requiera 
 traslación para que la secuencia quede sorteada. Por lo tanto, podemos afirmar que, en el peor de los casos, el número máximo de traslaciones será

á
En particular, el número máximo de iteraciones sobre toda la secuencia de números es 
. Esta última observación será de utilidad para simplificar el pseudocódigo, que se muestra a continuación.

Algoritmo: Sorteo de burbuja.

Entrada: una secuencia finita de n números.

Salida: una secuencia finita de n números ordenados de menor a mayor.

Pseudocódigo

1 Para cada i desde 1 hasta n
2     Para cada j desde 1 hasta n-1
3         Si A[j] es mayor que A[j+1]
4             Intercambia a A[j] y A[j+1]
Una implementación en Julia de este pseudocódigo se ve como sigue:


#Implementación de nuestro pseudocódigo de "Bubble sort" en Julia

A = [5, 7, 13, 27, 59, 4] #¡Cambia este arreglo de números y ejecuta la celda de nuevo!
n = length(A)

for i in 1:n                            # Para cada i desde 1 hasta n
    for j in 1:(n-1)                    #     Para cada j desde 1 hasta n-1
        if A[j] > A[j+1]                #         Si el elem. izq. es mayor al derecho
            A[j], A[j+1] = A[j+1], A[j] #             Itercámbialos
        end
    end
end

print(A)
     
Ejercicio Piensa en otra forma de solucionar el problema de sorteo distinta del sorteo de burbuja. Luego:

Descríbela con tus palabras de la forma más clara posible.
Argumenta si crees que sería una solución correcta y por qué (no es necesario demostrarlo).
Especula alrededor de su eficiencia en cuanto a espacio (memoria) y tiempo.
Intenta representar tu solución con un diagrama de flujo.
Representa tu solución con un pseudocódigo.
La intención del ejercicio es que repases, refuerces y pienses mucho en lo que hemos visto en este notebook, por lo que vale mucho más un intento de solución propia -aunque sea incorrecta- que una solución correcta que no hayas obtenido por tu cuenta.

Nota Más allá de los problemas más prácticos hemos mencionado anteriormente, muchos problemas de matemáticas "puras" también se resuelven mediante algoritmos computacionales. Por ejemplo, el algoritmo de la división (de Euclides) en aritmética, que sirve para dividir dos números enteros, o el proceso de Gram-Schmidt en álgebra lineal, que sirve para ortogonalizar conjuntos finitos linealmente independientes en espacios vectoriales con producto escalar. Particularmente, para el segundo caso, una representación visual de la solución a dicho problema se puede apreciar en este video, así como una representación en forma de pseudocódigo al final del mismo.

Recursos complementarios
Cormen, Leiserson, Rivest y Stein, Introduction to Algorithms, Capítulos 1 "The Role of Algorithms in Computing" y 2 "Getting Started", págs. 5-42.
Video Visualization of 24 Sorting Algorithms In 2 Minutes.
Sitio web Sort Visualizer.
Sitio web interactivo Comparison Sorting Algorithms.
Video Ortogonalización y ortonormalización (Teorema de Gram-Schmidt) del canal de YouTube Animathica.
Página de Wikipedia de Flowcharts.
